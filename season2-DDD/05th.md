# エリックエヴァンス ドメイン駆動設計 第3回
この`Cervelo`のバイクの詳細を知りたい。（この本の出版が2003年なのでけっこう古いモデルな気がするけど。。。）

## 第10章 しなやかな設計
たとえ、ドメインモデルの発見に成功しても、ソフトウェアの設計がイケていないと、リファクタリングや保守をすることが困難になる。そうすると、「修正によって何が影響するかわからない」状態になり、重複した処理が生産され、しまいにはリファクタリングとイテレーションによる改良が限界を迎える。
何をもってイケているかどうかを判断するか。それは、 **使う人** と **保守する人** のどちらにとっても明確で利用しやすい形に加工されているか否かによって判断される。

### 意図の明白なインターフェース
```
渡辺謙「本当に世の中のオブジェクトは（気にしなければいけないことが）細かすぎて、（プログラムが）書けなーい！！」
渡辺謙「コンポーネントも！ライブラリも！（気にしなければいけないことが）細かすぎて、（プログラムが）書けない！」
渡辺謙「でも、`意図の明確なインターフェース`を使うと、世界は変わる。気にせず書けちゃうんです。」
```

カプセル化したクラスとメソッドに適切な名前をプログラム要素に与えることで、開発者間のコミュニケーションを豊かにすることができる。
そのためには、目的に沿った名前を宣言する必要がある。手段を示してはならない。

### 副作用のない関数
操作は`コマンド（Command）`と`クエリ（Query）`の二つに大別できる。
- コマンド：システムに何らかの変更を与える操作
- クエリ：システムから情報を取得する操作

**システムに何らかの変更を与えるコマンド**のことを`副作用のある操作`と呼ぶ。逆に、副作用を起こさない操作のことを`関数`と呼ぶ。

副作用のある操作は、結果の予測が困難で、予期せぬ影響を与えることがあるため、それはそれは、とてもめんどくさいものである。

#### 副作用を減らす方法
副作用のリスク/影響を減らす方法として、  
- **コマンドとクエリを別々の操作に分離する方法**
    - 副作用のある場合はドメインデータを返さない
    - クエリと演算は全て副作用を起こさないメソッドにする
- **既存のオブジェクトを変更せずに処理の結果を表す新しいオブジェクトを返却する方法**

疑問）１つめの方法の、ドメインデータはエンティティのこと？エンティティに`void`の操作を追加するってことか？それとも、レポジトリとファクトリをうまく使えってこと？

### 表明
いかに副作用を減らしたとしても、エンティティには副作用を作り出すコマンドが残ってるやで。
だから、副作用があることを明示的に`表明`する必要があるやで。  
特に、オーバーエンジニアリングされている場合は副作用が紛れこみやすいから気をつけるんやで。

- 実装によって暗黙的に定義されている
- 委譲が多く行われている

これらのような場合は、結局ソースコードを追うことになって、せっかくのカプセル化が崩壊してしまうやで。

表明は
- 操作の事後条件とクラスと集約の不変条件を宣言する（xxxdoc的なコメントのこと？）
- ユニットテストを書く
- ドキュメントや図を使って明示すること

とはいえ、モデルがイケていれば、意図や副作用を推測しやすくなるので、モデルを蒸留するのがもっとも有効。

### 概念の輪郭
モデルの統一感を求めることは過度の単純化なので、モデルが破綻してしまう。
外部インターフェースも、いくつかのモデルの一面によって構成されているものなので、概念を適切にモデル化するのも困難である。とはいえ、モデル化を推し進めすぎると、クライアント側が複雑になってしまいかねない。最悪の場合はモデルが崩壊する可能性すらある。  
しかも、見つけ出したモデルも他のモデルと矛盾していることがある。

しかし、ドメインの根底には一貫性があるから、（モデルに対する）リファクタリングを通して高い凝集と低い結合を探していく行為を繰り返すことで、いつしか矛盾が収まり、概念が収斂し、輪郭が現れる。

ドメインモデルとして完結させるためにも、技術的思考に引きずられてはならない。シンプルなインターフェイスをとっていけば、最終的にユビキタス言語と１対１にもなる。

### 独立したクラス
依存関係が増えるとつらみ。だから、低い結合で自己完結なオブジェクト（モデル？）に分解する。複雑な依存関係があるなら、その依存関係をモデルとして表す。

### 閉じた操作
上記の総まとめなので、割愛。
読むよりも自分で実装してみてもいいかも。
